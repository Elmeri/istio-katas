!INCLUDE "markdown-source/meta.md"
[//]: # (Tags: #sentences #kiali)

# Routing Traffic with Istio

## Learning goals

- Using Virtual Services
- Using Destination Rules

## Introduction

This exercise introduce you to the basics of traffic routing with Istio. 
We are going to deploy all the services for our sentences application 
and a new version `v2` of the **name** service. This will demonstrate normal 
kubernetes load balancing between services. 

Then we are going to use two Istio custom resource definitions([CRD's](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/)) which are
the building blocks of Istio's traffic routing functionality to route traffic to 
the desired workloads.

These are the [VirtualService](https://istio.io/latest/docs/reference/config/networking/virtual-service/) and the [DestinationRule](https://istio.io/latest/docs/reference/config/networking/destination-rule/) CRD's.

### VirtualService

You use virtual services to route traffic to kubernetes services. 

VirtualService is used in addition to the normal Kubernetes service object.
A VirtualService defines a set of traffic routing rules to apply when a host 
is addressed. 

Each routing rule defines matching criteria for traffic of a 
specific protocol. If the traffic is matched, then it is sent to a named 
destination **service** or subset/version of it.

An example of a VirtualService is seen below:

```yaml
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: myservice-route
spec:
  hosts:
  - myservice
  gateways:
  - mesh
  http:
  - route:
    - destination:
        host: myservice-v1
        subset: myservice-v1
    - destination:
        host: myservice-v2
        subset: myservice-v1
```

- The **http** block is an [HTTPRoute](https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPRoute) 
containing the routing rules for HTTP/1.1, HTTP/2 and gRPC traffic. 

> You can also use [TCPRoute](https://istio.io/latest/docs/reference/config/networking/virtual-service/#TCPRoute) 
> and [TLSRoute](https://istio.io/latest/docs/reference/config/networking/virtual-service/#TLSRoute) 
> blocks for configuring routing.

- The **hosts** field is the user addressable destination that the routing rules 
apply to. It is the address used by a client when attempting to connect to a service.
This is **virtual** and doesn't actually have to exist. For example 
You could use it for consolidating routes to all services for an application. 

- The **destination** field specifies the **actual** destination of the routing 
rule and **must** exist. In kubernetes this is a **service** and generally 
takes a form like `reviews`, `ratings`, etc.

- The `mesh` field in the gateways block is a reserved keyword used to imply 
**all** sidecars in the mesh.

- The subset block is the name of a subset within the service and **must** be 
defined in a **DestinationRule**.

### DestinationRule

Destination rules configure **what** happens to traffic for a destination 
defined in a virtual service.

You can think of virtual services as **how** you route your traffic to a given 
destination, and then you use destination rules to configure **what** happens 
to traffic for that destination.

One of the most common uses of `DestinationRule` is to specify named service **subsets**.

For example, grouping all of a service instances **versions**. You can then 
use these **subsets** in a virtual service to control traffic to different versions.

```yaml
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: my-destination-rule
spec:
  host: myservice
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
  - name: v3
    labels:
      version: v3
```

> Destination rules are applied by Istio **after** virtual service routing 
> rules are **evaluated**, so they apply to the traffic’s “real” destination.

## Exercise: Routing To Specific Version

We will look a bit into how a VirtualService and a DestinationRule can control 
the flow of traffic in your namespace. We spin up two versions of the name 
service in the namespace, and use the VirtualService and DestinationRule kinds 
to control the traffic.

### Overview

- Deploy the sentences app and two versions (`name-v1` and `name-v2`) of the 
name service

- Run the script `scripts/loop-query.sh` to produce traffic

- Use the **Versioned app graph** in Kiali to observe the traffic flow

> What you will observe is normal k8's load balancing.

- Create a DestinationRule with **subsets** for the `name-v1` and `name-v2` 
workloads

- Create a a VirtualService to route **all** traffic to version 1 of the name 
service

> A virtual service lets you configure **how** requests are routed 
> to a **service** within an Istio service mesh. A destination 
> rule defines what happens after the traffic is routed to a service.

- Add a route to version 2 of the name service as the **first** route

- Use the **Versioned app graph** in Kiali to observe the traffic flow

### Step by Step
<details>
    <summary> More Details </summary>

- **Deploy sentences app and 2 versions of name services**

```console
kubectl apply -f 001-basic-traffic-routing/start/
kubectl apply -f 001-basic-traffic-routing/start/name-v1
kubectl apply -f 001-basic-traffic-routing/start/name-v2
```

- **Run loop-query.sh**

```console
./scripts/loop-query.sh
```

- **Observe the traffic in Kiali**

Go to Graph menu item and select the **Versioned app graph** from the drop 
down menu.

![50/50 split of traffic](images/kiali-blue-green-anno.png)

What you are seeing here is kubernetes load balancing between PODS.
Kubernetes, or more specifically the `kube-proxy`, will load balance in 
either a *round robin* or *random* pattern depending on whether it is 
running in *user space* proxy mode or *IP tables* proxy mode.

You rarely want traffic routed to two version in an uncontrolled 
fashion.

So why is this happening?

> :bulb: Take a look at the label selector for the name service.
> It doesn't specify a version...

- **Create a destination rule and apply it**

Create a destination rule called `name-dr.yaml` in 
`001-basic-traffic-routing/start/` and apply it.

```yaml
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: name-destination-rule
spec:
  host: name
  exportTo:
  - "."
  subsets:
  - name: name-v1
    labels:
      version: v1
  - name: name-v2
    labels:
      version: v2
```
The above destination rule says, when combined with a virtual service, **what** 
I want to do is send traffic to a workload **labeled** with either `v1` or `v2`.

```console
kubectl apply -f 001-basic-traffic-routing/start/name-dr.yaml
```
Applying the destination rule has no effect at this point because there is no 
virtual service including the destination rule.

> :bulb: To avoid 503 errors **always** apply destination rules and changes to 
> destination rules **prior** to changing virtual services.

- **Create a `VirtualService` to route ALL traffic to version 1 of the name 
service** 

Create a virtual service called `name-vs.yaml` in 
`001-basic-traffic-routing/start/` and apply it.

```yaml
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: name-route
spec:
  hosts:
  - name
  exportTo:
  - "."
  gateways:
  - mesh
  http:
  - route:
    - destination:
        host: name
        subset: name-v1
```

> The `host` field in the above yaml is the kubernetes short name for the service. 
> Istio will translate the short name based one the **namespace** of the rule. 
> E.g. if the virtual service is in namespace `default` the short name name will 
> be interpreted as `name.default.svc.cluster.local`. What will happen if the 
> **name** service is in the namespace `user1`?

```console
kubectl apply -f 001-basic-traffic-routing/start/name-vs.yaml
```

Go to **Graph** menu item in Kiali and select the **Versioned app graph** 
from the drop down menu and observe the traffic flow. It may take a minute 
before fully complete but you should see the traffic being routed to the 
`name-v1` **service**.

> :bulb: Make sure to select `Idle Edges`, `Service Nodes` and 
> `Virtual Services` in the Display drop down.

![Basic virtual service route](images/basic-route-vs.png)

You can see in Kiali that the virtual service combined with the destination 
rule subsets routes traffic to the name workload labeled `v1` even though the 
name service has no versions defined in the selector.

- **Add a route to version 2 of the name service as the **first** route**

Add a destination to the new service in the `name-vs.yaml` you 
created before. But place it **before** the `name-v1` service and apply it.

```yaml
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: name-route
spec:
  hosts:
  - name
  exportTo:
  - "."
  gateways:
  - mesh
  http:
  - route:
    - destination:
        host: name
        subset: name-v2
  - route:
    - destination:
        host: name
        subset: name-v1
```

```console
kubectl apply -f 001-basic-traffic-routing/start/name-vs.yaml
```

- **Use the versioned app graph to observe route precedence in Kiali**

Go to **Graph** menu item in Kiali and select the **Versioned app graph** 
from the drop down menu and observe the traffic flow. You will see that 
traffic is now being routed to the version 2 service.

![Routing precedence](images/basic-route-precedence-vs.png)

Routing rules are evaluated in **sequential** order from top to bottom, with 
the first rule in the virtual service definition being given highest priority. 

Reorder the destination rules so that service `name-v1` will be evaluated 
first and apply the changes.

```console
kubectl apply -f 001-basic-traffic-routing/start/name-vs.yaml
```

Go to **Graph** menu item in Kiali and select the **Versioned app graph** 
from the drop down menu and observe the traffic flow.Traffic should once more  
be routed to the `name-v1` service.

![Virtual service and destination rule](images/basic-route-vs.png)

</details>

# Summary

In this exercise you learned what a virtual service is and how to route traffic 
to a destination service in kubernetes with an [HTTPRoute](https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPRoute).

> Kubernetes only supports traffic distribution based on instance scaling. 

There is a lot more virtual services can do for traffic distribution like 
match conditions for HTTPRoute on headers, uri, schemes, etc. HTTP redirects, 
rewrites and more. We will looking at some of these in following exercises.

See the [documentation](https://istio.io/latest/docs/reference/config/networking/virtual-service/#VirtualService) 
for more details.

You also saw how a destination rule could be used to determine **what** 
happens to traffic routed to a kubernetes service using labels identifying 
workload versions. But you can also set traffic policies on a destination rule 
to apply load balancing policies, connection pool settings, etc.

See the [documentation](https://istio.io/latest/docs/reference/config/networking/destination-rule/#DestinationRule) 
for more details.

# Cleanup

```console
kubectl delete -f 001-basic-traffic-routing/start/name-v2
kubectl delete -f 001-basic-traffic-routing/start/name-v1
kubectl delete -f 001-basic-traffic-routing/start/
```
