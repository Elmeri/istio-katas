!INCLUDE "markdown-source/meta.md"
[//]: # (Tags: #TLS #mutual-tls #PKI-domains #ingress-gateway #VirtualService #Gateway #PeerAuthentication #DestinationRule)

# Securing with Mutual TLS <----- WIP (Work In Progress)

## Learning goals

- Secure communication between services
- Secure communication with mesh external services

## Introduction

This exercise will demonstrate how to use mutual TLS inside the mesh between
PODs with the Istio sidecar injected and also from mesh-external services
accessing the mesh through an ingress gateway.

You will be using several Istio custom resource 
definitions([CRD's](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/)) 
for this. But the main two dealing with TLS are.

- [PeerAuthentication](https://istio.io/latest/docs/reference/config/security/peer_authentication/#PeerAuthentication-MutualTLS) - 
Applies to requests that a service **receives**

- [DestinationRule](https://istio.io/latest/docs/reference/config/networking/destination-rule/#DestinationRule) - 
What type of TLS sidecar **sends**

### PeerAuthentication

Istio provides two types of authentication policies of which *peer 
authentication* is one of them. 

Peer authentication is used for **service-to-service** authentication 
to verify the client making the connection and secure the 
service-to-service communication. Istio uses 
[mutual TLS](https://en.wikipedia.org/wiki/Mutual_authentication)(mTLS) 
for transport authentication. 

This provides a **strong identity** for each workload. Peer authentication 
is normally enabled at the `cluster/mesh` level, as is our training 
infrastructure, which means traffic is secured by default for all services 
in the cluster **without** requiring code changes. 

> Istio has it's own certificate authority(CA) and securely provisions strong 
> identities to every workload with X.509 certificates. Istio agents, running 
> alongside each Envoy proxy, work together with istiod to automate key and 
> certificate rotation at scale. 

<details>
    <summary> :bulb: More About Workload Identity </summary>

Istio provisions keys and certificates through the following flow:

- istiod offers a gRPC service to take certificate signing requests (CSRs).

- When started, the Istio agent creates the private key and CSR, and then 
sends the CSR with its credentials to istiod for signing.

- The CA in istiod validates the credentials carried in the CSR. Upon 
successful validation, it signs the CSR to generate the certificate.

- When a workload is started, Envoy requests the certificate and key from 
the Istio agent in the same container via the Envoy secret discovery 
service (SDS) API.

- The Istio agent sends the certificates received from istiod and the private 
key to Envoy via the Envoy SDS API.

- Istio agent monitors the expiration of the workload certificate. 

The above process repeats periodically for certificate and key rotation.

</details>

There are four modes that can be set for mTLS.

- UNSET - Modes is inherited from parent, defaults to PERMISSIVE

- DISABLE - Connection is **not** tunneled 

- PERMISSIVE - Connection can be either plaintext or mTLS tunnel

- STRICT - Connection is an mTLS tunnel (TLS with client cert must be presented)

> PeerAuthentication defines how traffic will be tunneled (or not) to the sidecar.

The PeerAuthentication CRD is used to specify the mTLS settings for a workloads 
**requests**.

An example of a peer authentication policy is seen below:

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: foo
spec:
  mtls:
    mode: PERMISSIVE
---
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: foo
spec:
  selector:
    matchLabels:
      app: myapp
  mtls:
    mode: STRICT
```

The above policy says to allow **both** plain-text and mTLS traffic for **all** 
workloads in the `foo` namespace but **require** mTLS for the workload `myapp` 
in the `foo` namespace.

- The `namespace` definition scopes the policy to the defined namespace.

> If a policy is **not** namespace scoped it applies to **all** workloads 
> within the mesh. There can be only one mesh-wide peer authentication policy, 
> and only one namespace-wide peer authentication policy per namespace. If you 
> configure more then Istio will ignore the newer policies.

- The `selector` determines the workload to apply the ChannelAuthentication to.

You can also specify the mTLS mode at the **port** level **if** you specify 
a `selector`. 

```yaml
spec:
  selector:
    matchLabels:
      app: myapp
  mtls:
    mode: UNSET
  portLevelMtls:      
    9012:
      mode: DISABLE
```

### DestinationRule

The DestinationRule CRD is used to specify the TLS settings for upstream 
connections. E.g. traffic the workload sends. These settings are common for 
both HTTP and TCP connections. 

In a destination rule you use the `tls` keyword instead of the `mtls` keyword 
under `spec.trafficPolicy`.

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: upstream-mtls
spec:
  host: upstream-app
  trafficPolicy:
    tls:                        # tls instead of mtls
      mode: MUTUAL
      clientCertificate: /etc/certs/myclientcert.pem
      privateKey: /etc/certs/client_private_key.pem
      caCertificates: /etc/certs/rootcacerts.pem
```

The modes are different also. 

- DISABLE - Do not setup a TLS connection to the upstream endpoint.

- SIMPLE - Originate a TLS connection to the upstream endpoint.

- MUTUAL - Secure connections to the upstream using **mutual** TLS by 
presenting client certificates for authentication.

> You **must** specify the certificates when modes is set to MUTUAL.

- ISTIO_MUTUAL - Same as MUTUAL except you do **not** specify the 
client certificates as the certs generated for mTLS by Istio are used.

## Exercise: Mutual TLS Inside the Mesh

You will deploy all the services for the sentences application to observe 
the affects of mTLS configuration **without** sidecars. Afterwards you will 
inject sidecars and observe the effects of the mTLS configuration.

### Overview

- Deploy the sentences application and observe sidecars

- Run the script `./scripts/loop-query-mtls.sh` 

- Observe the traffic flow with Kiali

- Create peer authentication requiring `STRICT` mTLS

- Observe the traffic flow with Kiali

- Enable sidecar for the age service 

- Observe the traffic flow with Kiali

- Allow un-encrypted and un-authenticated traffic using `PERMISSIVE` mTLS

- Observe the traffic flow with Kiali

- Inject sidecars for all services

- Re-enabled `STRICT` mTLS

- Observe the traffic flow with Kiali


### Step by Step
<details>
    <summary> More Details </summary>

- **Deploy the sentences application and observe sidecars**

```console
kubectl apply -f 005-securing-with-mtls/
```

Execute `kubectl get pods` and observe that we have one container per POD, 
i.e. **no Istio sidecars injected**.

```
NAME                         READY   STATUS    RESTARTS   AGE
age-657d4d9678-q8h7d         1/1     Running   0          3s
name-86969f7468-4qfmp        1/1     Running   0          3s
sentences-779767c659-mlcm9   1/1     Running   0          4s
```

- **Run the script `./scripts/loop-query-mtls.sh`**

Execute the following to retrieve sentences and thus update Istio metrics.

```console
./scripts/loop-query-mtls.sh
```

- **Observe the traffic flow with Kiali**

Go to Graph menu item and select the **Versioned app graph** from the drop 
down menu. Select the checkboxes as shown in the below image.

If we observe the result in Kiali, we will see that we only have information
about traffic from the ingress gateway towards the frontend sentences service
and that mTLS is not being used (later we will see how Kiali denotes that mTLS
is in use and be able to see the difference from this view).:


TODO: Update this image!
![Kiali with no sidecars](images/kiali-no-sidecar-no-mtls-anno.png)

- **Create peer authentication requiring `STRICT` mTLS**

Create a file called `peer-authentication.yaml` in 
`005-securing-with-mtls/start/`.

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
spec:
  mtls:
    mode: STRICT
```

Apply the peer authentication.

```console
kubectl apply -f 005-securing-with-mtls/start/peer-authentication.yaml
```

- **Observe the traffic flow with Kiali**

Go to Graph menu item and select the **Versioned app graph** from the drop 
down menu.

We see, that traffic still flows, which is because the sentences services do not
have an Istio sidecar and the strict peer-authentication policy we created only
applies to the namespace where we created it and it is only applied when
validating requests made *towards* a workload with an Istio sidecar. I.e. even
if we created a strict policy in the namespace of the ingress gateway, traffic
would still flow.

TODO: Update this image!
![Kiali with no sidecars](images/kiali-no-sidecar-no-mtls-anno.png)

- **Enable sidecar for the age service**

Inject a sidecar for the **age** service.

```console
cat 005-securing-with-mtls/age.yaml |grep -v inject | kubectl apply -f -
```

Wait for the pod to be redeployed. 

```console
kubectl get pods
```

You should see it being terminated and new instantiated.

```console
Todo add some output here!
```

- **Observe the traffic flow with Kiali**

Go to Graph menu item and select the **Versioned app graph** from the drop 
down menu. Select the checkboxes as shown in the below image.

After this we see, that traffic no longer flows. This is because the frontend 
sentences service do not have an Istio sidecar and hence do not use mTLS 
towards the `age` service which now require mTLS.

Inspect the result in Kiali - we see 100% errors:

TODO: Update this image!
![Kiali with no sidecars](images/kiali-mtls-error.png)

- **Allow un-encrypted and un-authenticated traffic using `PERMISSIVE` mTLS**

Modify the `peer-authentication.yaml` in `005-securing-with-mtls/start/` 
to use `PERMISSIVE` mode.

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
spec:
  mtls:
    mode: PERMISSIVE
```

> While migrating an application to full mTLS, it may be useful to start with 
> a `PERMISSIVE` mTLS mode which allow a mix of mTLS and un-encrypted and 
> un-authenticated traffic.

```console
kubectl apply -f 005-securing-with-mtls/peer-authentication.yaml
```

- **Observe the traffic flow with Kiali**

Go to Graph menu item and select the **Versioned app graph** from the drop 
down menu. Select the checkboxes as shown in the below image.

The traffic is now flowing but we see a disjointed graph and `unknown` 
traffic. Think about why that is happening.

TODO: Add needed image.
![Disjointed graph](images/kiali-disjointed-graph.png)

> Hint: Which services have sidecars providing metrics for Kiali?

- **Inject sidecars for all services**

Lets inject Istio sidecars into all sentences services:

```console
cat 005-securing-with-mtls/*.yaml |grep -v inject | kubectl apply -f -
```

Wait for the pods to be redeployed.

```console
kubectl get pods
```

You should see them being terminated and new instantiated.

```console
Todo add some output here!
```

- **Re-enabled `STRICT` mTLS**

Since **all** services now have an Istio sidecar, we can enable strict mTLS:

Modify the `peer-authentication.yaml` in `005-securing-with-mtls/start/` 
to use `STRICT` mode.

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
spec:
  mtls:
    mode: STRICT
```

```console
kubectl apply -f 005-securing-with-mtls/peer-authentication.yaml
```

- **Observe the traffic flow with Kiali**

Go to Graph menu item and select the **Versioned app graph** from the drop 
down menu. Select the checkboxes as shown in the below image.

Now we can see in Kiali, that mTLS is enabled between all services of the
sentences application (in the view below, the link between the frontend and the
`age` service has been selected):

TODO: Update the below image
![Full mTLS](images/kiali-mtls-anno.png)

----- FINISH BELOW -----

To show how we can control egress mTLS settings with a DestinationRule, we
create one that use mTLS towards `v2` of the `name` service and no mTLS for
`v1`. Note that we now need to use a `PERMISSIVE` PeerAuthentication:

```console
kubectl apply -f 005-securing-with-mtls/peer-auth/permissive.yaml
kubectl apply -f 005-securing-with-mtls/dest-rule/name.yaml
```

Note, that a DestinationRule *will not* take effect until a route rule
explicitly sends traffic to the subset, hence in `005-securing-with-mtls/dest-rule.yaml` we
also define a VirtualService which routes to the subsets.

Now we see a missing padlock on the traffic towards `v1`:

![No mTLS towards v1](images/kiali-mtls-destrule-anno.png)

</details>

## Mutual TLS from External Clients through Ingress Gateways

This exercise extends the server-side TLS we tried out in [exercise Multiple
Teams and Separation of Duties](multi-teams.md). Create a Certificate authority
and certificate as follows (or reuse the one from the previous exercise):

### Overview

- 
- 

### Step by Step
<details>
    <summary> More Details </summary>

First, ensure that the gateway and virtual service from the first part of this
exercise is removed - we re-create them later with TLS enabled:

```console
kubectl delete -f 005-securing-with-mtls/igw/gateway-http.yaml
kubectl delete -f 005-securing-with-mtls/igw/virtual-service-http.yaml
```

We must have the sentences application deployed with sidecars (this might
already be the case, unless you skipped some of the first part of this
exercise):

```console
cat 005-securing-with-mtls/*.yaml |grep -v inject | kubectl apply -f -
```

Create the certificate authority:

```console
openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj '/O=example Inc./CN=example.com' -keyout example.com.key -out example.com.crt
openssl req -out sentences.example.com.csr -newkey rsa:2048 -nodes -keyout sentences.example.com.key -subj "/CN=sentences.example.com/O=ACMEorg"
openssl x509 -req -days 365 -CA example.com.crt -CAkey example.com.key -set_serial 0 -in sentences.example.com.csr -out sentences.example.com.crt
```

Also, since we will be using mTLS, we need to create a client certificate we can
use when accessing the sentences application through the ingress gateway:

```console
openssl req -out client.example.com.csr -newkey rsa:2048 -nodes -keyout client.example.com.key -subj "/CN=client.example.com/O=ACMEorg"
openssl x509 -req -days 365 -CA example.com.crt -CAkey example.com.key -set_serial 1 -in client.example.com.csr -out client.example.com.crt
```

Create a kubernetes secret in the Kubernetes namespace in which the ingress
gateway is defined (see [exercise Multiple Teams and Separation of
Duties](multi-teams.md) for details on this):

```console
export SENTENCES_INGRESSGATEWAY_NS=istio-system
kubectl -n $SENTENCES_INGRESSGATEWAY_NS create secret generic sentences-tls-secret --from-file=cert=sentences.example.com.crt --from-file=key=sentences.example.com.key --from-file=cacert=example.com.crt
```

Also create a new Gateway and VirtualService to use the secret for TLS:

```console
kubectl -n $SENTENCES_INGRESSGATEWAY_NS apply -f 005-securing-with-mtls/igw/gateway.yaml
cat 005-securing-with-mtls/igw/virtual-service.yaml | envsubst | kubectl apply -f -
```

Finally, we query the sentences application using HTTPS and mTLS with the
following command:

```console
scripts/loop-query-loadbalancer-ep.sh https+mtls
```

Note the curl options (printed when the script starts) that specify the
certificate authority and also the client certificate and key which is required
for mTLS:

</details>

### Summary

PKI (Public Key Infrastructure) does not necessarily mean, that we are using
internet-scoped public/private key encryption. In this exercise we have seen how
we can leverage the Istio-internal PKI to implement mTLS inside the Istio mesh
between PODs with Istio sidecars. We have also seen how to setup mTLS for Istio
ingress gateways. For internet-accessible traffic, a likely cloud architecture
could be the following, where we have a load balancer in front of the ingress
gateways that implement internet-trusted TLS termination and DoS protection and
where we have mTLS between elements behind the load balancer. This provides
end-to-end protection of traffic.

![Cloud infrastructure mTLS](images/istio-cloud-mtls.png)

## Cleanup

```console
kubectl delete -f 005-securing-with-mtls/start/
kubectl -n istio-ingress delete secret <YOUR_NAMESPACE>-sentences-tls-secret
```
